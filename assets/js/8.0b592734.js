(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{430:function(t,s,a){"use strict";a.r(s);var _=a(15),e=Object(_.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),a("p",[t._v("栈是保证我们的程序能够递归进行的数据结构，程序调用过程中使用的局部变量，保存返回地址，保存栈帧等等。")]),t._v(" "),a("h1",{attrs:{id:"堆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[t._v("#")]),t._v(" 堆")]),t._v(" "),a("p",[t._v("堆是程序在运行过程中需要使用内存的动态分布的区域，堆是我们自己申请能够使用的地盘。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://i.loli.net/2021/04/20/3YrQhLGCU7ca1wD.jpg",alt:"chunk.png"}})]),t._v(" "),a("h2",{attrs:{id:"常见堆实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见堆实现"}},[t._v("#")]),t._v(" 常见堆实现")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("dlmalloc")]),t._v(" -通用分配器")]),t._v(" "),a("p",[a("code",[t._v("ptmalloc2 - glibc")]),t._v(" (基于"),a("code",[t._v("dlmalloc fork")]),t._v("出来，在2006年增加了多线程支持)")]),t._v(" "),a("p",[a("code",[t._v("jemalloc")]),t._v(" - FreeBSD、Firefox、Android")]),t._v(" "),a("p",[a("code",[t._v("libumem")]),t._v(" - Solaris")]),t._v(" "),a("p",[a("code",[t._v("Windows 10")]),t._v(" - segment heap")])]),t._v(" "),a("h4",{attrs:{id:"ptmalloc2-的多线程支持"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ptmalloc2-的多线程支持"}},[t._v("#")]),t._v(" "),a("code",[t._v("ptmalloc2")]),t._v(" 的多线程支持")]),t._v(" "),a("ul",[a("li",[t._v("不同的线程维护不同的堆。称为 "),a("code",[t._v("per thread arena")]),t._v(".")]),t._v(" "),a("li",[t._v("主线程创建的堆，称为 "),a("code",[t._v("main arena")]),t._v(".")]),t._v(" "),a("li",[a("code",[t._v("Arena")]),t._v(" 数量收到CPU核数的限制.\n"),a("ul",[a("li",[t._v("对于32位系统：arena数量上限 = 2*核数.")]),t._v(" "),a("li",[t._v("对于64位系统：arena数量上限 = 8*核数.")])])])]),t._v(" "),a("h4",{attrs:{id:"glibc的堆管理实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#glibc的堆管理实现"}},[t._v("#")]),t._v(" "),a("code",[t._v("glibc")]),t._v("的堆管理实现")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("arena")])]),t._v(" "),a("ul",[a("li",[t._v("指的是堆内存区域本身，并非结构.")]),t._v(" "),a("li",[t._v("主线程的"),a("code",[t._v("main arena")]),t._v("通过"),a("code",[t._v("sbrk")]),t._v("创建.")]),t._v(" "),a("li",[t._v("其他线程"),a("code",[t._v("arena")]),t._v("通过"),a("code",[t._v("mmap")]),t._v("创建.")])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("malloc_state")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("管理"),a("code",[t._v("arena的")]),t._v("核心结构，包含堆的状态信息、"),a("code",[t._v("bins")]),t._v("链表等.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("main arena")]),t._v("对应的"),a("code",[t._v("malloc_state")]),t._v("结构存储在"),a("code",[t._v("glibc")]),t._v("的全局变量中.")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("malloc_state")]),t._v(" main_arena"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* global variable in libc.so */")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])])])])]),t._v(" "),a("li",[a("p",[t._v("其他线程"),a("code",[t._v("arena")]),t._v("对应的"),a("code",[t._v("malloc_state")]),t._v("存储在"),a("code",[t._v("arena")]),t._v("本身当中.")])])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("bins")])])]),t._v(" "),a("li",[a("p",[t._v("bins用来管理空闲的内存块，通常使用链表结构来进行组织.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("chunks")])]),t._v(" "),a("ul",[a("li",[t._v("内存块的结构.")])])])]),t._v(" "),a("h6",{attrs:{id:"free-chunk-结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#free-chunk-结构"}},[t._v("#")]),t._v(" "),a("code",[t._v("free chunk")]),t._v(" 结构")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://i.loli.net/2021/04/20/YlhjQkenSZvmEaV.jpg",alt:"Free_chunk.jpg"}})]),t._v(" "),a("ul",[a("li",[t._v("在64位平台下，free chunk的第一个字段"),a("code",[t._v("prev_size")]),t._v("(8字节)存储了前一个chunk的大小.")]),t._v(" "),a("li",[a("code",[t._v("free chunk")]),t._v("的第二个字段size记录了当前chunk的大小，该字段最低三个bit被用作其他含义。P代表"),a("code",[t._v("PREV_ INUSE")]),t._v("，即代表前一个chunk是否被使用。M代表"),a("code",[t._v("IS_ _MMAPPED")]),t._v(",代表当前chunk是否是"),a("code",[t._v("mmap")]),t._v("出来的。N代表"),a("code",[t._v("NON_ _MAIN_ ARENA")]),t._v(",代表改chunk是否属于非"),a("code",[t._v("Main_Arena")]),t._v("。")]),t._v(" "),a("li",[t._v("第三字段"),a("code",[t._v("fd")]),t._v("和第四字段"),a("code",[t._v("bk")]),t._v(" (8字节) 前向指针和后向指针,这两个字段用于bin链表当中，用来链接大小相同或者相近的"),a("code",[t._v("free chunk")]),t._v(",便于后续分配时查找。")])]),t._v(" "),a("h6",{attrs:{id:"malloc参数与chunk大小的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#malloc参数与chunk大小的关系"}},[t._v("#")]),t._v(" "),a("code",[t._v("malloc")]),t._v("参数与"),a("code",[t._v("chunk")]),t._v("大小的关系")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("malloc")]),t._v("参数位用户申请的内存大小.")]),t._v(" "),a("li",[a("code",[t._v("chunk")]),t._v("包含数据和"),a("code",[t._v("metadata")]),t._v(".")]),t._v(" "),a("li",[t._v("返回的"),a("code",[t._v("chunk")]),t._v("只要保证其中可用数据大小大于等于用户申请即可.")]),t._v(" "),a("li",[t._v("在x86 32位平台下，"),a("code",[t._v("chunk")]),t._v("的大小一定是8字节的整数倍；x64平台下，"),a("code",[t._v("chunk")]),t._v("的大小一定是16字节的整数倍")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://i.loli.net/2021/04/20/FoT5aE2SvVmgpCQ.jpg",alt:"chunk.jpg"}})]),t._v(" "),a("h6",{attrs:{id:"bins结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bins结构"}},[t._v("#")]),t._v(" "),a("code",[t._v("bins")]),t._v("结构")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("Bins")]),t._v("是用来管理和组织空闲内存块的链表结构，根据"),a("code",[t._v("chunk")]),t._v("的大小和状态，有许多不同的"),a("code",[t._v("bins")]),t._v("结构.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("Fast bins")])]),t._v(" "),a("ul",[a("li",[t._v("用于管理小的"),a("code",[t._v("chunk")]),t._v(".")])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("Bins")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("small bins")]),t._v(" - 用于管理中等大小的"),a("code",[t._v("chunk")]),t._v(".")]),t._v(" "),a("li",[a("code",[t._v("large bins")]),t._v(" - 用于管理较大的"),a("code",[t._v("chunk")]),t._v(".")]),t._v(" "),a("li",[a("code",[t._v("unsorted bins")]),t._v(" - 用于存放未整理的"),a("code",[t._v("chunk")]),t._v(".")])])])]),t._v(" "),a("h4",{attrs:{id:"fast-bins"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fast-bins"}},[t._v("#")]),t._v(" "),a("code",[t._v("Fast bins")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("大小")]),t._v(" "),a("ul",[a("li",[t._v("x86_32位平台:16~64字节.")]),t._v(" "),a("li",[t._v("x64平台:32~128字节.")])])]),t._v(" "),a("li",[a("p",[t._v("相同大小的chunk放在一个bin中.")])]),t._v(" "),a("li",[a("p",[t._v("单向链表")])]),t._v(" "),a("li",[a("p",[t._v("后进先出(first in last out)")])]),t._v(" "),a("li",[a("p",[t._v("相邻的空闲fast bin chunk不会被合并.")])]),t._v(" "),a("li",[a("p",[t._v("当chunk被free时，不会清理"),a("code",[t._v("PREV_INUSE")]),t._v("标志")])])]),t._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("malloc_state")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Serialize access.  */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("__libc_lock_define")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mutex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Flags (formerly in max_fast).  */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" flags"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Set if the fastbin chunks contain recently inserted free blocks.  */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Note this is a bool but not all targets support atomics on booleans.  */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" have_fastchunks"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Fastbins */")]),t._v("\n  mfastbinptr fastbinsY"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NFASTBINS"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Base of the topmost chunk -- not otherwise kept in a bin */")]),t._v("\n  mchunkptr top"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* The remainder from the most recent split of a small request */")]),t._v("\n  mchunkptr last_remainder"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Normal bins packed as described above */")]),t._v("\n  mchunkptr bins"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NBINS "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Bitmap of bins */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" binmap"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("BINMAPSIZE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Linked list */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("malloc_state")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("next"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Linked list for free arenas.  Access to this field is serialized\n     by free_list_lock in arena.c.  */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("malloc_state")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("next_free"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Number of threads attached to this arena.  0 if the arena is on\n     the free list.  Access to this field is serialized by\n     free_list_lock in arena.c.  */")]),t._v("\n  INTERNAL_SIZE_T attached_threads"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Memory allocated from the system in this arena.  */")]),t._v("\n  INTERNAL_SIZE_T system_mem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  INTERNAL_SIZE_T max_system_mem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br"),a("span",{staticClass:"line-number"},[t._v("19")]),a("br"),a("span",{staticClass:"line-number"},[t._v("20")]),a("br"),a("span",{staticClass:"line-number"},[t._v("21")]),a("br"),a("span",{staticClass:"line-number"},[t._v("22")]),a("br"),a("span",{staticClass:"line-number"},[t._v("23")]),a("br"),a("span",{staticClass:"line-number"},[t._v("24")]),a("br"),a("span",{staticClass:"line-number"},[t._v("25")]),a("br"),a("span",{staticClass:"line-number"},[t._v("26")]),a("br"),a("span",{staticClass:"line-number"},[t._v("27")]),a("br"),a("span",{staticClass:"line-number"},[t._v("28")]),a("br"),a("span",{staticClass:"line-number"},[t._v("29")]),a("br"),a("span",{staticClass:"line-number"},[t._v("30")]),a("br"),a("span",{staticClass:"line-number"},[t._v("31")]),a("br"),a("span",{staticClass:"line-number"},[t._v("32")]),a("br")])]),a("h4",{attrs:{id:"small-bins"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#small-bins"}},[t._v("#")]),t._v(" "),a("code",[t._v("Small bins")])]),t._v(" "),a("ul",[a("li",[t._v("chunk大小 < 1024bytes(64bit).")]),t._v(" "),a("li",[t._v("相同大小的chunk放在一个bin中.")]),t._v(" "),a("li",[t._v("双向循环链表.")]),t._v(" "),a("li",[t._v("先进先出(First in First out).")]),t._v(" "),a("li",[t._v("当有空闲块相邻时，chunk会被合并成一个更大的chunk.")]),t._v(" "),a("li",[t._v("bin[2],bin[3],……,bin[124],bin[125]共62组"),a("code",[t._v("smallbin")]),t._v("，大小范围[0x20,0x3f0]（64位）")])]),t._v(" "),a("h4",{attrs:{id:"large-bins"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#large-bins"}},[t._v("#")]),t._v(" "),a("code",[t._v("Large bins")])]),t._v(" "),a("ul",[a("li",[t._v("chunk 大小 >= 1024bytes(64位)")]),t._v(" "),a("li",[t._v("每组bin表示一组size范围而不是具体的size，例如bins[126],bins[127]的链表中保存长度在[0x400,0x440]的chunk")]),t._v(" "),a("li",[t._v("双向循环链表")]),t._v(" "),a("li",[t._v("先进先出")]),t._v(" "),a("li",[t._v("chunk按照大小从大到小排序")]),t._v(" "),a("li",[t._v("当有空闲块相邻，chunk会被合并")]),t._v(" "),a("li",[t._v("bins[126],bins[127],....,bins[250],bins[251]共63组"),a("code",[t._v("largebin")]),t._v(",大小范围[0x400,X]（64位）")]),t._v(" "),a("li",[t._v("每组bins中的chunk大小不一定相同，按由大到小的顺序在链表中排列.")])]),t._v(" "),a("h4",{attrs:{id:"unsorted-bin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unsorted-bin"}},[t._v("#")]),t._v(" "),a("code",[t._v("Unsorted bin")])]),t._v(" "),a("ul",[a("li",[t._v("64位平台中:chunk大小 > 128字节")]),t._v(" "),a("li",[t._v("只存在唯一一个"),a("code",[t._v("unsorted bin")])]),t._v(" "),a("li",[t._v("双向循环链表")]),t._v(" "),a("li",[t._v("当一个chunk(非fast bin)被free，他首先被放入"),a("code",[t._v("unsorted bin")]),t._v(",等后续整理时才会放入对应的"),a("code",[t._v("small bin/large bin")])]),t._v(" "),a("li",[t._v("bin[0],bin[1]")])]),t._v(" "),a("h4",{attrs:{id:"其他chunk"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他chunk"}},[t._v("#")]),t._v(" "),a("code",[t._v("其他chunk")])]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("Top chunk")])]),t._v(" "),a("ul",[a("li",[t._v("不属于任何bin")]),t._v(" "),a("li",[t._v("在arena中处于最高地址")]),t._v(" "),a("li",[t._v("当没有其他空闲块时，top chunk就会被用于分配")]),t._v(" "),a("li",[t._v("分裂时\n"),a("ul",[a("li",[t._v("一块时请求大小的chunk")]),t._v(" "),a("li",[t._v("另一块余下的chunk将成为新的top chunk")])])])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("Last_remainder")])]),t._v(" "),a("ul",[a("li",[t._v("当请求small chunk大小的内存时，如发生分裂，则剩余的chunk保存为"),a("code",[t._v("Last_remainder")])])])])]),t._v(" "),a("h4",{attrs:{id:"malloc-的工作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#malloc-的工作流程"}},[t._v("#")]),t._v(" malloc()的工作流程")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("1.如果"),a("code",[t._v("size < max fast")]),t._v(", 在"),a("code",[t._v("fast bins")]),t._v(" 中寻找"),a("code",[t._v("fast chunk")]),t._v(",如找到则结束.")])]),t._v(" "),a("li",[a("p",[t._v("2.如果"),a("code",[t._v("size in_ smallbin_ range")]),t._v(", 在"),a("code",[t._v("small bins")]),t._v("中寻找"),a("code",[t._v("small chunk")]),t._v("，如找到则结束.")])]),t._v(" "),a("li",[a("p",[t._v("3.如果"),a("code",[t._v("size not in_ smallbin_ range")]),t._v(", 合并所有"),a("code",[t._v("fastbin")]),t._v("的chunk")])]),t._v(" "),a("li",[a("p",[t._v("4.循环")])]),t._v(" "),a("li",[a("p",[t._v("a.检查"),a("code",[t._v("unsorted bin")]),t._v("中的"),a("code",[t._v("last_remainder")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("i")]),t._v(". 如果满足一-定条件,则分裂之，将剩余的chunk标记为新的"),a("code",[t._v("last_remainder")])])])]),t._v(" "),a("li",[a("p",[t._v("b.在"),a("code",[t._v("unsorted bin")]),t._v("中搜索，同时进行整理")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("i")]),t._v(".如遇到精确大小， 则返回,否则就把当前chunk整理到"),a("code",[t._v("small/large bin")]),t._v("中去")]),t._v(" "),a("li",[t._v("c.在"),a("code",[t._v("small bin")]),t._v("和"),a("code",[t._v("large bin")]),t._v("中搜索最合适的chunk(不一定是精确大小)")])])]),t._v(" "),a("li",[a("p",[t._v("5.使用"),a("code",[t._v("top chunk")])])])]),t._v(" "),a("h4",{attrs:{id:"free-工作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#free-工作流程"}},[t._v("#")]),t._v(" free()工作流程")]),t._v(" "),a("ul",[a("li",[t._v("1.如果"),a("code",[t._v("size < max fast")]),t._v(", 放入"),a("code",[t._v("fast bin")]),t._v(", 结束.")]),t._v(" "),a("li",[t._v("2.。如果前一个chunk是free的\n"),a("ul",[a("li",[t._v("a. "),a("code",[t._v("unlink")]),t._v("前面的chunk.")]),t._v(" "),a("li",[t._v("b.合并两个chunk， 并放入"),a("code",[t._v("unsorted bin")]),t._v(".")])])]),t._v(" "),a("li",[t._v("3.如果后一个chunk是"),a("code",[t._v("top chunk")]),t._v(",则将当前chunk并入"),a("code",[t._v("top chunk")]),t._v(".")]),t._v(" "),a("li",[t._v("4.如果后一个chunk时"),a("code",[t._v("free")]),t._v("的\n"),a("ul",[a("li",[t._v("a. "),a("code",[t._v("unlink")]),t._v("后面的chunk.")]),t._v(" "),a("li",[t._v("b. 合并两个chunk,并放入"),a("code",[t._v("unsorted bin")]),t._v(".")])])]),t._v(" "),a("li",[t._v("5.前后chunk都不是free的， 放入"),a("code",[t._v("unsorted bin")]),t._v(".")])]),t._v(" "),a("h4",{attrs:{id:"unlink的操作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unlink的操作流程"}},[t._v("#")]),t._v(" unlink的操作流程")]),t._v(" "),a("ul",[a("li",[t._v("chunk开始是这样的")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("前一个chunk的bk")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("<------")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[a("code",[t._v("fd")])]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}}),t._v(" "),a("th")])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}}),t._v(" "),a("td",{staticStyle:{"text-align":"center"}}),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("code",[t._v("bk")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("<------")]),t._v(" "),a("td",[t._v("后一个chunk的"),a("code",[t._v("fd")])])])])]),t._v(" "),a("ul",[a("li",[t._v("unlink后")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("前一个chunk的"),a("code",[t._v("bk")])]),t._v(" "),a("th",[t._v("<-----------")]),t._v(" "),a("th",[t._v("后一个chunk的"),a("code",[t._v("fd")])])])]),t._v(" "),a("tbody",[a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td")])])]),t._v(" "),a("h4",{attrs:{id:"realloc的操作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#realloc的操作流程"}},[t._v("#")]),t._v(" "),a("code",[t._v("realloc")]),t._v("的操作流程")]),t._v(" "),a("ul",[a("li",[t._v("当 "),a("code",[t._v("realloc(ptr,size)")]),t._v(" 的 "),a("code",[t._v("size")]),t._v(" 不等于 "),a("code",[t._v("ptr")]),t._v(" 的 "),a("code",[t._v("size")]),t._v(" 时\n"),a("ul",[a("li",[t._v("如果申请 size > 原来 size\n"),a("ul",[a("li",[t._v("如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小")]),t._v(" "),a("li",[t._v("如果 chunk 与 top chunk 不相邻，相当于 "),a("code",[t._v("free(ptr)")]),t._v(","),a("code",[t._v("malloc(new_size)")])])])]),t._v(" "),a("li",[t._v("如果申请 size < 原来 size\n"),a("ul",[a("li",[t._v("如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变")]),t._v(" "),a("li",[t._v("如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分")])])])])]),t._v(" "),a("li",[t._v("当 "),a("code",[t._v("realloc(ptr,size)")]),t._v(" 的 size 等于 0 时，相当于 "),a("code",[t._v("free(ptr)")])]),t._v(" "),a("li",[t._v("当 "),a("code",[t._v("realloc(ptr,size)")]),t._v(" 的 size 等于 "),a("code",[t._v("ptr")]),t._v(" 的 size，不进行任何操作")])]),t._v(" "),a("h4",{attrs:{id:"fastbin-attack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fastbin-attack"}},[t._v("#")]),t._v(" "),a("code",[t._v("Fastbin attack")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Fast bin")]),t._v("利用技术\n"),a("ul",[a("li",[a("code",[t._v("Fast bin")]),t._v("为单向链表，结构简单，容易伪造.")]),t._v(" "),a("li",[t._v("为了提高效率,安全检查较少.")]),t._v(" "),a("li",[t._v("只针对"),a("code",[t._v("Fast bin")]),t._v("大小的chunk， "),a("code",[t._v("small/large chunk")]),t._v("不适用.")])])]),t._v(" "),a("li",[t._v("利用思路\n"),a("ul",[a("li",[t._v("空闲"),a("code",[t._v("Fast chunk")]),t._v("如果发生溢出被覆盖，则链表指针"),a("code",[t._v("fd")]),t._v("可以被修改.")]),t._v(" "),a("li",[t._v("可以通过修改链表指针"),a("code",[t._v("fd")]),t._v("，在"),a("code",[t._v("Fast bin")]),t._v("链表中弓|入伪造的空闲"),a("code",[t._v("Fast chunk")]),t._v(".")]),t._v(" "),a("li",[t._v("下次分配时分配出伪造的"),a("code",[t._v("Fast chunk")]),t._v(".")]),t._v(" "),a("li",[t._v("伪造的"),a("code",[t._v("Fast chunk")]),t._v("可以在"),a("code",[t._v(".bss")]),t._v("全局变量处，也可以在栈上,当然堆也是可以的.")])])])])])}),[],!1,null,null,null);s.default=e.exports}}]);